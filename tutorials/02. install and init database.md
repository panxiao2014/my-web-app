It is common that backend uses a database for data storage. In this tutorial we'll use a simple database table to store user information. After this tutorial you can add more complex tables with the code framework.

We use Postgresql. Install it on the local host, creating a user named postgres and a database named userdb.

Then create a table named users with four columns:

```
#enter psql command line with username and password:
psql -U postgres

#create table in psql command line:
\c userdb

CREATE TABLE public.users (
    id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name varchar(40) NOT NULL,
    gender varchar(6) NOT NULL,
    age integer NOT NULL,
    CONSTRAINT users_age_check CHECK (age >= 0 AND age <= 100),
    CONSTRAINT users_gender_check CHECK (gender IN ('Male', 'Female'))
);
```

Then we can dump this table to Python database schema. Create a folder named "users" in backend/app. And create the schema:

```
pip install sqlacodegen
pip install psycopg2-binary

sqlacodegen postgresql://<username>:<password>@localhost:5432/userdb --outfile backend/app/users/models.py
```

Verify that a class named "Users" is created in file models.py.

Now we'll update backend code so it will connect to the database at startup and create two user records in the table that we can query them later.

For security issue, never write any password in source code and push it to remote repository. Create the following folder and file:

**backend/tokens/postgresql.txt**

Write the database password in the text file, and add the folder to **.gitignore** file:

```
backend/tokens/
```

Create file **backend/app/users/userdb_utils.py**. We add functions to connect to database and create two default user records:

```
"""
Common utilities for user database operations.
This module contains shared functions used across user-related database operations.
"""

import os
import sys
import json
from pathlib import Path
from sqlalchemy import create_engine, inspect, text
from sqlalchemy.orm import sessionmaker
from .models import Base, Users
from pathlib import Path
from fastapi import FastAPI


def get_db_host() -> str:
    return "localhost"
    

def read_postgres_password() -> str:
    """
    Read PostgreSQL password from environment variable or file.
    
    Returns:
        str: The PostgreSQL password
        
    Raises:
        RuntimeError: If password is not found in environment variable or file
    """
    tokens_path = Path(__file__).resolve().parent.parent.parent / "tokens" / "postgresql.txt"
    try:
        return tokens_path.read_text(encoding="utf-8").strip()
    except FileNotFoundError:
        raise RuntimeError(f"PostgreSQL password not found in environment variable POSTGRES_PASSWORD or file at: {tokens_path}")

def seed_database():
    """Seed the database with test users."""
    try:
        db_host = get_db_host()
        password = read_postgres_password()
        # Get database connection
        
        database_url = f"postgresql+psycopg2://postgres:{password}@{db_host}:5432/userdb"
        
        # Create engine and session
        engine = create_engine(database_url, pool_pre_ping=True)
        SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
        
        # Ensure the users table exists (supports custom __tablename__ changes)
        inspector = inspect(engine)
        users_table_name = Users.__tablename__
        if not inspector.has_table(users_table_name):
            sys.exit(1)
        
        # Create session
        db = SessionLocal()
        
        try:
            # Check if users already exist
            existing_users = db.query(Users).count()
            if existing_users > 0:
                return
            
            # Create test users
            test_users = [
                Users(name="Alice", gender="Female", age=25),
                Users(name="Bob", gender="Male", age=30),
            ]
            
            # Add users to database
            for user in test_users:
                db.add(user)
            
            # Commit changes
            db.commit()

            # Verify the seeded users can be retrieved
            retrieved = db.query(Users).filter(Users.name.in_([u.name for u in test_users])).all()
            retrieved_names = {u.name for u in retrieved}
            expected_names = {u.name for u in test_users}
            if retrieved_names != expected_names:
                sys.exit(1)
            
            for user in retrieved:
                print(f"  - {user.name} ({user.gender}, age {user.age})")
                
        except Exception as e:
            db.rollback()
            print(f"üõí Error seeding database: {e}")
            sys.exit(1)
        finally:
            db.close()
            
    except Exception as e:
        print(f"üõí Error connecting to database: {e}")
        sys.exit(1)

def init_database_session(app: FastAPI):
    """
    Initialize database session for the application.
    
    Args:
        app: FastAPI application instance
    """
    db_host = get_db_host()

    try:
        password = read_postgres_password()
        database_url = f"postgresql+psycopg2://postgres:{password}@{db_host}:5432/userdb"
        engine = create_engine(database_url, pool_pre_ping=True)
        # Probe connectivity early to fail fast
        with engine.connect() as conn:
            conn.execute(text("SELECT 1"))
        SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    except Exception as exc:
        message = "Failed to initialize database session to host '{host}': {err}".format(
            host=db_host, err=str(exc)
        )
        raise RuntimeError(message) from exc

    app.state.db_engine = engine
    app.state.db_session_factory = SessionLocal

    return
```

We'll update this file when we need to support Docker and AWS deployment later.

Now update **main.py** so the backend will connect and initialize database when start:

```
from fastapi import FastAPI
from contextlib import asynccontextmanager
from fastapi.middleware.cors import CORSMiddleware
from app.config.config import TEST_PING
from app.users.userdb_utils import init_database_session, seed_database

@asynccontextmanager
async def lifespan(app: FastAPI):
    try:
        init_database_session(app)
    except Exception as e:
        print(f"‚ùå Failed to initialize database session: {e}")
        raise
    seed_database()
    try:
        yield
    finally:
        if hasattr(app.state, 'db_engine'):
            app.state.db_engine.dispose()

app = FastAPI(title="my-learning-app API", lifespan=lifespan)

# Allow frontend dev server
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # in production, restrict to your domain
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/ping")
async def ping():
    return {"message": TEST_PING}
```

To verify if two default users are created in database:
```
psql -U postgres
\c userdb
select * from users;
```


