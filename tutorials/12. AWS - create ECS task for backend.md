After ECS cluster is created we can continue to create task and service. ECS Task defines the container image we are going to run. ECS Service defines the deployment strategy of the task. We'll create a task and service for the frontend application, a task and service for the backend application. Separating frontend and backend in different services gives us flexibility. For example if there is performance bottleneck on backend application we can scale it up by adding more running instances, without changing the frontend.

First we create task for backend. Navigate to **ECS --> Task definitions --> Create new task definition**. Fill in the following:

>Task definition family: my-backend-task
>
>Launch type: AWS Fargate
>
>CPU: 0.5 vCPU
>
>Memory: 1 GB
>
>Task execution role: Create new role
>
>Contianer name: backend
>
>Image URI: click **Browse ECR images**, choose **my-learning-app-registry**, select image **my-backend-latest**, and click **Use image tag**
>
>Container port: 8000
>
>Port name: backend-port
>
>Log collection: enable **Use log collection**

For the **Environment variables**, we'll create two variables.

First we need to get the database address so our backend application could connect to it. Open a new browser window, navigate to **Aurora and RDS --> Databases --> userdb --> Connectivity & security**. Copy the value of **Endpoint**.

Back to the task definition window, add this value to the environment variable:

>KeyÔºöRDS_DATABASE_HOST
>
>Value type: Value
>
>Value: paste the database endpoint

Another variable is the database password that we have created it in previous tutorial. Open a new broswer window, navigate to **Secrets Manager --> Secrets --> my-db-secret**. Copy the value of **Secret ARN**.

Back to the task definition window, click **Add environment variable**, fill in the following:

>Key: POSTGRES_SECRET
>
>Value type: ValueFrom
>
>Value: paste the secret ARN

Click **Create**, backend task is now created.

To use these two variables, we need to update our backend code. In **backend --> app --> users --> userdb_utils.py**, update function **get_db_host()**:

```
    #If running in AWS, use RDS_DATABASE_HOST defined in backend task:
    if os.getenv("RDS_DATABASE_HOST"):
        logger.info("üê≥ Detected AWS, using 'RDS_DATABASE_HOST'")
        return os.getenv("RDS_DATABASE_HOST")
    
    # If running inside Docker, use docker network hostname
    if os.getenv("RUNNING_IN_DOCKER"):
        logger.info("üê≥ Detected Docker via RUNNING_IN_DOCKER env, using 'postgres'")
        return "postgres"

    # Otherwise, fallback to localhost
    logger.info("üñ•Ô∏è Not running in Docker, using 'localhost'")
    return "localhost"
```

Update function **read_postgres_password()**Ôºö

```
    """
    Read PostgreSQL password from environment variable or file.
    
    Returns:
        str: The PostgreSQL password
        
    Raises:
        RuntimeError: If password is not found in environment variable or file
    """
    # Try to get from environment variable (for AWS deployment)
    # the value is got from the AWS Secrets Manager by secret ARN, which is defined in the AWS Task and have the following format:
    # {"username":"postgres","password":"<password>","engine":"postgres","host":"userdb.abcdefg.ap-northeast-3.rds.amazonaws.com","port":5432,"dbInstanceIdentifier":"userdb"}
    postgres_secret = os.getenv("POSTGRES_SECRET")
    if postgres_secret:
        print(f"üê≥ Detected POSTGRES_SECRET")
        return json.loads(postgres_secret)["password"]
    
    # try to get from environment variable (for CI/CD in Github Actions)
    postgres_password = os.getenv("POSTGRES_PASSWORD")
    if postgres_password:
        print(f"üê≥ Detected POSTGRES_PASSWORD")
        return postgres_password
    
    #get password from local file
    tokens_path = Path(__file__).resolve().parent.parent.parent / "tokens" / "postgresql.txt"
    try:
        return tokens_path.read_text(encoding="utf-8").strip()
    except FileNotFoundError:
        raise RuntimeError(f"PostgreSQL password not found in environment variable POSTGRES_PASSWORD or file at: {tokens_path}")
```

Make sure our test cases can pass both in local pytest and Github Actions flows.

Every time when we have updated code we need to rebuild the docker image, push it to AWS registry. Following steps in [Create Docker registry and push images](09.%20AWS%20-%20create%20Docker%20registry%20and%20push%20images.md). We only need to update backend image since there is no code change in frontend.

When we created this task, an IAM role named **ecsTaskExecutionRole** is created automatically. Since this task needs to read secret from Secrets Manger, we must add permission to this role.

Navigate to **IAM --> Roles --> ecsTaskExecutionRole**. Click **Add permissions** and select **Attach policies**. Search and select **SecretsManagerReadWrite**.